<script>
// Super Attractive Loader JavaScript with Percentage Animation
class SuperAttractiveLoader {
  constructor(loaderId) {
    this.loaderId = loaderId;
    this.loader = document.getElementById(loaderId);
    this.timeout = null;
    this.isActive = false;
    this.percentage = 0;
    this.animationFrameId = null;
    this.progressCircle = null;
    this.percentageDisplay = null;
    this.startTime = null;

    this.init();
  }

  init() {
    if (!this.loader) return;

    this.progressCircle = this.loader.querySelector('.progress-ring-fill');
    this.percentageDisplay = this.loader.querySelector('.percentage-number');

    if (this.progressCircle) {
      const radius = 80;
      const circumference = 2 * Math.PI * radius;
      this.progressCircle.style.strokeDasharray = circumference;
      this.progressCircle.style.strokeDashoffset = circumference;
      this.circumference = circumference;
    }
  }

  // Show loader with optional delay and duration
  show(delay = 1000, estimatedDuration = 3000) {
    if (this.isActive) return;

    this.isActive = true;
    this.percentage = 0;
    this.startTime = null;
    this.estimatedDuration = estimatedDuration;

    if (delay > 0) {
      this.timeout = setTimeout(() => {
        if (this.isActive && this.loader) {
          this.displayLoader();
          this.startProgressAnimation();
        }
      }, delay);
    } else {
      if (this.loader) {
        this.displayLoader();
        this.startProgressAnimation();
      }
    }
  }

  // Hide loader immediately
  hide() {
    this.isActive = false;
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
    if (this.loader) {
      // Animate to 100% before hiding
      this.animateToCompletion(() => {
        this.loader.style.display = 'none';
        this.resetProgress();
      });
    }
  }

  displayLoader() {
    if (this.loader) {
      this.loader.style.display = 'block';
      // Add entrance animation
      this.loader.style.animation = 'none';
      this.loader.offsetHeight; // Trigger reflow
      this.loader.style.animation = null;
    }
  }

  startProgressAnimation() {
    this.startTime = Date.now();
    this.animateProgress();
  }

  animateProgress() {
    if (!this.isActive || !this.startTime) return;

    const currentTime = Date.now();
    const elapsed = currentTime - this.startTime;

    // Calculate progress based on estimated duration
    // Use easing function for smooth progression
    let progress = Math.min(elapsed / this.estimatedDuration, 0.95); // Don't go to 100% automatically

    // Apply easing function (ease-out)
    progress = 1 - Math.pow(1 - progress, 3);

    this.percentage = Math.floor(progress * 100);

    this.updateVisualProgress();

    if (this.isActive && this.percentage < 95) {
      this.animationFrameId = requestAnimationFrame(() => this.animateProgress());
    }
  }

  updateVisualProgress() {
    // Update percentage display
    if (this.percentageDisplay) {
      this.percentageDisplay.textContent = this.percentage;
    }

    // Update circular progress
    if (this.progressCircle && this.circumference) {
      const offset = this.circumference - (this.percentage / 100) * this.circumference;
      this.progressCircle.style.strokeDashoffset = offset;
    }

    // Update progress bar
    const progressBar = this.loader?.querySelector('.progress-bar-fill');
    if (progressBar) {
      progressBar.style.width = this.percentage + '%';
    }

    // Add visual effects based on percentage
    this.updateVisualEffects();
  }

  updateVisualEffects() {
    const container = this.loader?.querySelector('.loader-container');
    if (!container) return;

    // Remove existing classes
    container.classList.remove('loading-25', 'loading-50', 'loading-75', 'loading-90');

    // Add classes based on progress
    if (this.percentage >= 90) {
      container.classList.add('loading-90');
    } else if (this.percentage >= 75) {
      container.classList.add('loading-75');
    } else if (this.percentage >= 50) {
      container.classList.add('loading-50');
    } else if (this.percentage >= 25) {
      container.classList.add('loading-25');
    }
  }

  animateToCompletion(callback) {
    let currentPercentage = this.percentage;
    const targetPercentage = 100;
    const duration = 500; // 500ms to complete
    const startTime = Date.now();

    const animate = () => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);

      const easedProgress = 1 - Math.pow(1 - progress, 2); // Ease-out
      this.percentage = Math.floor(currentPercentage + (targetPercentage - currentPercentage) * easedProgress);

      this.updateVisualProgress();

      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        setTimeout(callback, 300); // Small delay before hiding
      }
    };

    animate();
  }

  resetProgress() {
    this.percentage = 0;
    if (this.percentageDisplay) {
      this.percentageDisplay.textContent = '0';
    }
    if (this.progressCircle && this.circumference) {
      this.progressCircle.style.strokeDashoffset = this.circumference;
    }
    const progressBar = this.loader?.querySelector('.progress-bar-fill');
    if (progressBar) {
      progressBar.style.width = '0%';
    }
  }

  // Check if loader is currently active
  isLoading() {
    return this.isActive;
  }

  // Set theme
  setTheme(theme) {
    if (this.loader) {
      this.loader.classList.remove('theme-success', 'theme-warning', 'theme-danger');
      if (theme) {
        this.loader.classList.add(`theme-${theme}`);
      }
    }
  }

  // Update loading text dynamically
  updateText(newText) {
    const titleElement = this.loader?.querySelector('.loading-title');
    if (titleElement) {
      titleElement.textContent = newText;
    }
  }

  // Simulate realistic loading progression
  simulateRealisticLoading(steps = []) {
    if (steps.length === 0) {
      // Default realistic loading steps
      steps = [
        { percentage: 15, delay: 200 },
        { percentage: 35, delay: 400 },
        { percentage: 60, delay: 600 },
        { percentage: 85, delay: 400 },
        { percentage: 95, delay: 200 }
      ];
    }

    let currentStep = 0;
    const executeStep = () => {
      if (currentStep < steps.length && this.isActive) {
        const step = steps[currentStep];
        this.percentage = step.percentage;
        this.updateVisualProgress();

        currentStep++;
        setTimeout(executeStep, step.delay);
      }
    };

    executeStep();
  }
}

// Helper function to create super attractive loader
function createSuperAttractiveLoader(loaderId) {
  return new SuperAttractiveLoader(loaderId);
}

// Enhanced helper function for search with super loader
function searchWithSuperLoader(searchFunction, loaderId, delay = 1000, estimatedDuration = 2000) {
  const loader = createSuperAttractiveLoader(loaderId);

  loader.show(delay, estimatedDuration);

  return Promise.resolve(searchFunction())
    .finally(() => {
      loader.hide();
    });
}

// Helper to enhance search inputs with super attractive loader
function enhanceSearchWithSuperLoader(searchInputId, loaderId, searchFunction, delay = 1000) {
  const searchInput = document.getElementById(searchInputId);
  const loader = createSuperAttractiveLoader(loaderId);
  let searchTimeout;

  if (!searchInput) return;

  searchInput.addEventListener('input', function(e) {
    clearTimeout(searchTimeout);
    loader.hide();

    const query = this.value.trim();
    if (query.length === 0) return;

    // Debounce search
    searchTimeout = setTimeout(() => {
      loader.show(delay, 2500); // 2.5 second estimated duration
      loader.simulateRealisticLoading();

      Promise.resolve(searchFunction(query))
        .finally(() => {
          loader.hide();
        });
    }, 300);
  });

  // Handle focus events
  searchInput.addEventListener('focus', function() {
    const query = this.value.trim();
    if (query.length > 0) {
      loader.show(delay, 2000);
      loader.simulateRealisticLoading();

      Promise.resolve(searchFunction(query))
        .finally(() => {
          loader.hide();
        });
    }
  });
}

// Global loader instance for easy access
window.createSuperAttractiveLoader = createSuperAttractiveLoader;
window.searchWithSuperLoader = searchWithSuperLoader;
window.enhanceSearchWithSuperLoader = enhanceSearchWithSuperLoader;
</script>